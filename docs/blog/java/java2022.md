# 天上飘来4个字，offer不是事！！

- java基础

- spring & springMVC

- mybatis、mybatisplus

- springboot & springcloudAlibaba

- redis & mongodb & mysql

- rabbitmq & kafka

- docker & linux

  [TOC]


## 一：java基础

### 1.1：java 面向对象三大特性（封装，继承，多态）？

封装：隐藏对象的属性和实现细节，仅对外公开接口，增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员

继承：实现代码的复用，但特别注意的是，父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。子类不能继承父类中访问权限为private的成员变量和方法

多态：相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同，例如方法重写重载。

### 1.2：抽象和接口的区别？

1、接口可以多实现，而抽象类只能单继承
2、抽象类可以有非抽象的方法和构造方法、变量，但是接口只能有抽象方法，静态常量。
3、抽象类和子类具有父子关系，子类能拥有父类中一些属性。接口虽然某个类实现一个接口，但是由于接口中的变量都为静态常量，​ 不存在继承关系。

### 1.3:  重写和重载？

**重载**： 在同一个类中，方法名必须相同，参数类型、个数、顺序不同，与返回值类型，访问修饰符无关，发生在编译时。

**重写**： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

### 1.4 ：String、StringBuffer、StringBuilder的区别?

可变性：三个都是处理字符串的方法，String底层使用final修饰了，所以是不可变的；StringBuilder 与 StringBuffer是可变的字符串;

安全性：String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是不线程安全

性能：每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String 对象，修改内容时性能低。StringBuffer、StringBuilder 每次都会对对象本身进行操作，而不是生成新的对象并改变对象引用；StirngBuilder的效率会高一些，而StringBuffer的底层加了同步的关键字，性能会有所下降

所以呢，一般我们操作少量的字符串的时候用String ，在单线程环境下操作大量数据时使用StringBuilder，在多线程操作大量数据使用StringBuffer。

### 1.5：java中的集合？

java 中的集合分为单列集合和双列集合，单列集合顶级接口为 Collection,双列集合顶级接口为 Map。

Collection 的子接口有两个：List 和 Set。 

Ø List 接口的特点：元素可重复，有序(存取顺序)。 list 接口的实现类如下：

​     Ø  ArrayList:底层实现是数组，查询快，增删慢，线程不安全，效率高；

​     Ø  Vector:底层实现是数组，查询快，增删慢，线程安全，效率低；【废弃】

​     Ø  LinkedList:底层实现是链表，增删快，查询慢，线程不安全，效率高；

Ø  Set 接口的特点：元素唯一，不可重复，无序。 Set 接口实现类如下：

​    Ø  HashSet:底层实现 hashMap，数组+链表实现，不允许元素重复，无序。

​    Ø  TreeSet:底层实现红黑二叉树，实现元素排序

Ø  Map 接口的特点：key-value 键值对形式存储数据 Map 接口实现类如下：

​    Ø  HashMap：底层数组+链表实现，线程不安全效率高；

​    Ø  TreeMap：底层红黑二叉树实现，可实现元素的排序；

​    Ø  LinkedHashMap：底层hashmap+linkedList 实现，通过 hashmap 实现 key-value 键值对存储，通过链表实现元素有序。

### 1.6：ArrayList和Linkedlist区别？

相同点：

1、二者都是 List 接口的实现类，具有元素可重复，有序(存取顺序)特点；

2、二者都是线程不安全，效率高； 

不同点：

1、数据结构：ArrayList底层数据结构是动态数组，LinkedList底层数据结构是双向链表；

2、随机访问效率：ArrayList比 LinkedList 在随机访问的时候效率要高，因为LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。

3、增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比ArrayList 效率要高，因为ArrayList 增删操作要影响数组内的其他数据的下标。

综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用LinkedList。

### 1.7：HashMap底层原理?

HashMap 底层是数组+链表(LinkedList)实现,hashMap 默认初始化容量为 16，也就 是说数组索引值为0-15，每个数组中存储一个链表。jdk1.8后当hash表的单一链表长度超过 8 个的时候，链表结构就会转为红黑树结构；当 hashmap 空间使用达到 0.75 后，会对数组进行扩容，新建数组，然后将元素拷 贝到新的数组中，每次扩容翻倍；在存储元素时有可能发生 hash 碰撞现象（即两个元素不相同，却有一样的 hash 值），这样的话，就将元素在数组中存入链表中，以链表的形式进行元素的存储，第一个entry 存在链表顶端，再有hash 值一致的entry 存入，则链接在第一个元素之后。

### 1.8：Java 到底是值传递还是引用传递？

Java 只支持值传递。
Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String或对象。
基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。

### 1.9：== 和equals有什么区别？

**==号**在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值；

**equals()**方法，默认效果和==号的效果一样，也是比较的地址值，然而，Java 提供的所有类中，绝大多数类都重写了 equals()方法，比如 string，integer 等，重写后的 equals()方法一般都是比较两个对象的值 

## **#{}****和${}的区别？**

\#{}是预编译，会在传入的值左右两边拼接，可以防止sql注入

${}是普通的拼接，不安全

### 1.10:java的类加载机制？

加载
ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。

验证
目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。

准备

为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。

解析
这里主要的任务是把常量池中的符号引用替换成直接引用

初始化
这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）

**简化：Jvm将.class文件加载到内存中，对数据进行校验和初始化以形成可用的java类的机制**

### 1.11:java的类加载顺序？

1:所有的类都会优先加载基类；
2:静态成员的初始化优先；
3:成员初始化后，才会执行构造方法；

4:静态成员的初始化与静态块的执行，发生在类加载的时候；成员加载在对象创建时；类对象的以及静态块的访问，都会触发类的加载。

**简化：先将类加载为基类，然后优先初始化静态成员，成员初始化后，最后执行构造方法**

### 1.12: 手写排序算法？

~~~java
//冒泡排序
public void bubbleSort(int []a){
           int len=a.length;
           for(int i=0;i<len;i++){
               for(int j=0;j<len-i-1;j++){
                   if(a[j]>a[j+1]){
                       int temp=a[j];
                       a[j]=a[j+1];
                       a[j+1]=temp;
                   }
               }
           }
       }

//选择排序
public void selectSort(int[]a){
        int len=a.length;
        for(int i=0;i<len;i++){//循环次数
            int value=a[i];
            int position=i;
            for(int j=i+1;j<len;j++){//找到最小的值和位置
                if(a[j]<value){
                    value=a[j];
                    position=j;
                }
            }
            a[position]=a[i];//进行交换
            a[i]=value;
        }
    }

~~~

### 1.13：设计模式

单例模式是保证一个类仅有一个实例，并自行提供访问该实例全局访问点的创建型模式。

~~~java
//懒汉式（线程安全）
public class Singleton {  
     private static Singleton instance;     
     private Singleton (){}         
     public static synchronized Singleton getInstance() {//加线程锁
        if (instance == null) {                 //判断如果没有实例              
            instance = new Singleton();         //新建一个实例
        }  
         return instance;                   //返回实例
     }  
}
~~~

工厂模式是为创建对象提供过渡接口，根据用户需求动态创建实例的设计模式。我们项目中接入短信服务是接入的是厂家或第三方的短信渠道，可以使用如下代码思路去实现工厂模式下发短信验证码

~~~java
public interface Phone {
    void make();
}

public class MiPhone implements Phone {
    public MiPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println("make xiaomi phone!");
    }
}

public class IPhone implements Phone {
    public IPhone() {
        this.make();
    }
    @Override
    public void make() {
        // TODO Auto-generated method stub
        System.out.println("make iphone!");
    }
}

public class PhoneFactory {
    public Phone makePhone(String phoneType) {
        if(phoneType.equalsIgnoreCase("MiPhone")){
            return new MiPhone();
        }
        else if(phoneType.equalsIgnoreCase("iPhone")) {
            return new IPhone();
        }
        return null;
    }
}

//测试
public class Demo {
    public static void main(String[] arg) {
        PHONEFACTOR factory = new PhoneFactory();
        Phone miPhone = factory.makePhone("MiPhone");            // make xiaomi phone!
        IPhone iPhone = (IPhone)factory.makePhone("iPhone");    // make iphone!
    }
}
~~~

观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己，我们使用的rabbitmq 中发布订阅（topic）消息类型就是一个典型的观察者模式使用的实例

### 1.14：jvm虚拟机的内存模型都有哪些？分别都存放那些数据？

JVM的运行时数据区分为五个区域：堆、栈、本地方法栈、方法区、计数器。

计数器：这里记录了线程执行的字节码的行号。

栈：每个方法执行的时候都会创建一个栈，用于存放 局部变量表、动态链接。

本地方法栈：与栈类似，是执行本地方法。

堆：堆就是存放对象实例，

方法区：用于存储Java虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等数据



### 1.15 ：GC垃圾回收算法？

标记-清除算法

算法分为2个阶段：1.标记需要回收的对象，2.回收被标记的对象，当进行过标记清除算法之后，内存碎片化比较严重，出现了大量的非连续内存。当java堆需要分配一段连续的内存给一个新对象时仍然需要继续清理以满足“连续空间”的要求。所以说，这种方法比较基础，效率也比较低下。

复制算法

它将内存划分为两块相等的大小，每次使用一块，当这一块用完了，就讲还存活的对象复制到另外一块内存区域中，然后将当前内存空间一次性清理掉。这样的对整个半区进行回收，不过这种算法将原有的内存空间减少为实际的一半，代价比较高，内存使用率不高

标记-整理算法

与标记清除算法一样，首先是标记对象然后清除，只不过清除后会自动整理内存碎片，将存货的对象向内存一段移动，整理出一块较大的连续内存空间。这样内存使用率高了，也是当前主推使用的GC垃圾回收算法

## 二： spring & springMVC

### 2.1: 介绍一下spring？

关于Spring的话，我们平时做项目一直都在用，不管是使用ssh还是使用ssm，都可以整合。Spring里面主要的就三点，也就是核心思想，IOC控制反转，DI依赖注入，AOP切面编程

我先来说说IOC吧，IOC就是spring里的控制反转，把类的控制权呢交给spring来管理，我们在使用的时候，在spring的配置文件中，配置好bean标签，以及类的全路径，如果有参数，然后在配置上相应的参数。这样的话，spring就会给我们通过反射的机制实例化这个类，同时放到spring容器当中去。

我们在使用的时候，需要结合DI依赖注入使用，把我们想使用的类注入到需要的地方就可以，依赖注入的方式有构造器注入、getset注入还有注解注入。我们现在都使用`@autowired`或者`@Resource`注解的方式注入。

然后就是AOP切面编程，他可以在不改变源代码的情况下对代码功能的一个增强。我们在配置文件中配置好切点，然后去实现切面的逻辑就可以实现代码增强，这个代码增强，包括在切点的执行前，执行中，执行后都可以进行增强逻辑处理，不用改变源代码，这块我们项目中一般用于权限认证、日志、事务处理这几个地方。

### 2.2 : AOP的实现原理？

这块呢，我看过spring的源码，底层就是动态代理来实现的，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了 ，目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理： 

- JDK 动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler 接口和 Proxy 类，InvocationHandler 通过 invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy 利用InvocationHandler 动态创建一个符合接口的的实例，生成目标类的代理对象。
- 如果代理类没有实现 InvocationHandler 接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现 AOP。CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。不过在我们的业务场景中没有代理过final的类，基本上都代理的controller层实现权限以及日志，还有就是service层实现事务统一管理

### 2.3 :  详细介绍下IOC容器

Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext

BeanFactory 是基础类型的 IoC 容器，提供了完整的 IoC 服务支持。简单来说，BeanFactory 就是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。

ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。

他俩的主要区别在于，如果 Bean 的某一个属性没有注入，则使用 BeanFacotry 加载后，在第一次调用 getBean() 方法时会抛出异常，但是呢ApplicationContext 会在初始化时自检，这样有利于检查所依赖的属性是否注入。

因此，在实际开发中，通常都选择使用 ApplicationContext

### 2.4：springbean的生命周期？

 spring容器可以管理 单例（singleton） 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。

而对于 prototype 作用域的 Bean，Spring只负责创建，当容器创建了 Bean 的实例后，就交给客户端代码管理，容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，都会创建一个新的实例



整体来说就4个步骤：实例化bean，属性赋值，初始化bean，销毁bean

- 首先就是实例化bean，容器通过获取BeanDefinition对象中的信息进行实例化
- 然后呢就是属性赋值，利用依赖注入完成 Bean 中所有属性值的配置注入
- 接着就是初始化bean，如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。
- 最后就是销毁bean，和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑

### 2.5： springbean的作用域？

Spring 容器中的 bean 可以分为 5 个范围： 

（1）singleton：单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。 controller、service、dao层基本都是singleton的

（2）prototype：原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。 

（3）request：在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。 

（4）session：在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。

（5）global-session：全局作用域，在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。

### 2.6：事务的传播特性？

| 属性名称                      | 值             | 描 述                                      |
| ------------------------- | ------------- | ---------------------------------------- |
| PROPAGATION_REQUIRED      | required      | 支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将创建新事务，默认就是这个 |
| PROPAGATION_SUPPORTS      | supports      | 支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将以非事务状态执行 |
| PROPAGATION_MANDATORY     | mandatory     | 支持当前事务。如果 A 方法没有事务，则抛出异常                 |
| PROPAGATION_REQUIRES_NEW  | requires_new  | 将创建新的事务，如果 A 方法已经在事务中，则将 A 事务挂起          |
| PROPAGATION_NOT_SUPPORTED | not_supported | 不支持当前事务，总是以非事务状态执行。如果 A 方法已经在事务中，则将其挂起   |
| PROPAGATION_NEVER         | never         | 不支持当前事务，如果 A 方法在事务中，则抛出异常                |
| PROPAGATION.NESTED        | nested        | 嵌套事务，底层将使用 Savepoint 形成嵌套事务              |

### 2.7：事务的隔离级别？

Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过 binlog实现的。隔离级别有四种

- Read uncommitted (读未提交)：读未提交，允许另外一个事务可以看到这个事务未提交的数据，最低级别，任何情况都无法保证。

- Read committed (读已提交)：保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新，可避免脏读的发生。

- Repeatable read (可重复读)：保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新，可避免脏读、不可重复读的发生。

- Serializable (串行化)：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新，可避免脏读、不可重复读、幻读的发生。


### 2.8：spring中都用了哪些设计模式？

（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；

（2）单例模式：Bean默认为单例模式。

（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；

（4）模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。

（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。

### 2.9：SpringMVC的执行流程？

l 用户发送请求至前端控制器；

l 前端控制器，调用处理器映射器，

l 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器一并返回给前端控制器；

l 前端控制器调用处理器适配器；

l 处理器适配器经过适配返回具体处理器；

l 处理器执行完成返回ModelAndView给前端控制器；

l 前端控制器将ModelAndView传给视图解析器进行解析；

l 视图解析器解析后返回具体视图；

l 前端控制器对视图进行渲染

l 前端控制器响应用户。



1.客户端（浏览器）发送请求，直接请求到DispatcherServlet。

2.DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler。

3.解析到对应的Handler（也就是我们平常说的Controller控制器）。

4.HandlerAdapter会根据Handler来调用真正的处理器来处理请求和执行相对应的业务逻辑。

5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View。

6.ViewResolver会根据逻辑View去查找实际的View。

7.DispatcherServlet把返回的Model传给View（视图渲染）。

8.把View返回给请求者（浏览器）。

### 2.10：springMVC中的常用注解？

@RequestMapping：指定类或者方法的请求路径，可以使用method字段指定请求方式

@GetMapping、@PostMapping：规定了请求方式的方法的请求路径

@RequestParam：接收单一参数的

@PathVariable：用于从路径中接收参数的

@CookieValue：用于从cookie中接收参数的

@RequestBody：用于接收js对象的，将js对象转换为Java对象

@ResponseBody：返回json格式数据

@RestController：用在类上，等于@Controller+@ResourceBody两个注解的和，一般在前后端分离的项目中只写接口时经常使用，标明整个类都返回json格式的数据

## 三：mybatis & mybatisplus

### 3.1： mybatis 的优缺点？

Mybatis是一个半ORM（对象关系映射）的持久层框架,它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程,使用时直接编写原生态sql。

l  优点：

1：基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理，提供XML标签，支持编写动态SQL语句，并可重用；

2：很好的与各种数据库兼容；

3：提供映射标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护。

4：与JDBC相比，消除了JDBC大量冗余的代码，不需要手动开关连接，能够与Spring很好的集成

l  缺点：

1：SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求；

2：SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库；

### 3.2: 当实体类中的属性名和表中的字段名不一样 ，怎么办？

第一种方法：通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致；

第二种方法：通过 <resultMap>来映射字段名和实体类属性名的一一对应的关系；

第三种方法：在实体类通过@Column注解也可以实现；

### 3.4 ：mybatis 如何执行批量插入?

第一种就是普通的xml中insert语句可以写成单条插入，在调用方循环N次;

第二种是xml中insert语句写成一次性插入一个N条的list，语法如下(核心便签 foreach collection***)

```xml
<insert id="insertBatch" >
    insert into person ( <include refid="Base_Column_List" /> ) 
    values 
        <foreach collection="list" item="item" index="index" separator=",">
        (null,#{item.name},#{item.sex},#{item.address})
    </foreach>
</insert>
```

### 3.5 :  Mybatis有哪些动态sql？

Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值完成逻辑判断并动态拼接sql的功能。

Mybatis提供了9种动态sql标签：

trim、where 、 set 、foreach、if 、choose、when 、otherwise 、bind

### 3.6 : MyBatis有哪写标签？

除了常见的select|insert|updae|delete标签之外，还有<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>`，加上动态sql的9个标签，其中`<sql>`为sql片段标签，通过`<include>`标签引入sql片段，`<selectKey>`为不支持自增的主键生成策略标签。

### 3.7:MyBatis 一级缓存和二级缓存？

一级缓存：Mybatis在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库；

MyBatis的二级缓存是Application级别的缓存，SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开席需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了<cache/>

### 3.8: MyBatis中${} 和#{}的区别？

l #{}是预编译处理，${}是字符串替换。

l 在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

l 在处理$$ {}时，就是把${}替换成变量的值。

l 使用#{}可以有效的防止SQL注入，提高系统安全性。

### 3.9：MyBatis执行原理描述？ 

MyBatis的主要设计目的就是让我们对执行SQL语句时对输入输出的数据管理更加方便，

他的执行流程包括

1：读取配置文件，配置文件包含数据库连接信息和Mapper映射文件或者Mapper包路径。

2：有了这些信息就能创建SqlSessionFactory，SqlSessionFactory的生命周期是程序级,程序运行的时候建立起来,程序结束的时候消亡

3： SqlSessionFactory建立SqlSession,目的执行sql语句，SqlSession是过程级,一个方法中建立,方法结束应该关闭

4：当用户使用mapper.xml文件中配置的的方法时，mybatis首先会解析sql动态标签为对应数据库sql语句的形式，并将其封装进MapperStatement对象，然后通过executor将sql注入数据库执行，并返回结果。

5： 将返回的结果通过映射，包装成java对象。

### 3.10：MyBatis 和MyBatisPlus的区别？

1：mybatisPlus 是对myBatis的增强，提供单表的crud操作，类似myabtis+tkMapper 

2：mybatisPlus内置丰富的条件构造器，比如，查询的QueryWrapper、LambdaQueryWrapper，修改的UpdateWrapper、

​      ge、gt、le、lt、isNull、isNotNull等条件构造器提供查询

## 四：springboot & springcloud

### 4.1：springboot优点？为什么选用springboot？

​     （1）简化配置， 它实现了自动化配置 ；

​	(2)提供maven极简配置，各种便捷的starter启动器；

​	(3)基于Spring构建，使开发者快速入门，门槛很低；

​	(4)内置tomcat服务器，SpringBoot可以创建独立运行的应用而不需要依赖于容器；

​	(5)为微服务SpringCloud奠定了基础，使得微服务的构建变得简单；

### 4.2：如何理解springboot 的starters ？

springboot 就是把众多优秀的框架整合起来，在boot项目通过引入starter启动器来实现开箱即用，因为它的存在，项目的依赖之间的关系对我们来说变的更加简单了

### 4.3： springboot自动配置原理？

springboot项目的核心注解@SpringbootApplication说起了，这个注解包含了三个注解，其中一个是@EnableAutoConfiguration注解，这个注解主要是开启自动配置的，这个注解会"猜"你将如何配置 spring，前提是你已经添加 了 jar 依赖项，比如项目中引入了 spring-boot-starter-web ，这个包里已经添加 Tomcat 和 SpringMVC，这个注解节就会自动假设您在开发一个 web 应用程序并添加相应的 spring 配置，springboot默认有一个spring-boot-autoconfigure包，大多数常用的第三方的配置都自动集成了，像redis、es等，这里边有一个`META-INF/spring.factories`文件，这里边定义了所有需要加载的bean的全路径，spring会根据反射的原理，创建这些对象，放到IOC容器中，加载时需要的参数，通过JavaConfig的方式加载配置文件中的参数然后创建了对应的对象，这就是自动配置的原理。

@EnableAutoConfiguration给容器导入META-INFO/spring.factories里的自动配置类，每一个自动配置类结合对应的properties读取配置文件后进行自动配置

### 4.4：Spring Boot 如何实现全局异常处理？

可以使用 `@ControllerAdvice` 和 `@ExceptionHandler` 处理全局异常

### 4.5：Spring boot 核心注解？

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下
3 个注解：
@SpringBootConﬁguration：组合了 @Conﬁguration 注解，实现配置文件的功能。
@EnableAutoConﬁguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：   

​                @SpringBootApplication(exclude = { DataSourceAutoConﬁguration.class })。
@ComponentScan：Spring组件扫描，从当前类所在的包以及子包扫描，之外的包扫描不到，所以我们在开发的时候，所有的类都在主类的子包下

### 4.6：spring cloud 的核心组件用到哪些？详细说一下他们各自的作用及请求的流程？

我们使用的是**springcloudAlibaba**系列的，主要使用到gateway网关，作用过滤和路由，通过filter过滤器配置过滤规则，routes路由到不同的微服务上；nacos注册中心，管理服务的注册与发现，同时也作为配置中心来用，把项目中的配置文件统一管理，实现热更改；ribbon负载均衡，应用内的服务集群下可做负载，策略有随机、轮训和权重；feign远程调用，做服务与服务之间的远程调用；sentinel限流与熔断，配置流控规则实现限流，熔断返回托底数据。

### 4.7：SpringCloud和Dubbo比较，谈谈个人看法？

springCloud和Dubbo都是现在主流的微服务架构，SpringCloud是Apache旗下的Spring体系下的微服务解决方案，Dubbo是阿里系的分布式服务治理框架；从技术维度上,个人觉得其实SpringCloud远远的超过Dubbo，,Dubbo本身只是实现了服务治理,而SpringCloud现在以及后续有好多个子项目以后还可能会更多。服务的调用方式Dubbo使用的是RPC远程调用,而SpringCloud使用的是 Rest API,其实更符合微服务官方的定义，服务网关,Dubbo并没有本身的实现,只能通过其他第三方技术的整合,而SpringCloud有gateway路由网关,作为路由服务器,进行消费者的请求分发，SpringCloud还支持断路器等其他组件等。

### 4.8：spring、springMVC、springboot、springcloud 的区别与联系？

Spring是一个生态体系（也可以说是一个技术体系）是集大成者，包括Spring Framework、Spring Boot、Spring Cloud等；

 Springframework框架他们的基础都是Spring 的 ioc和 aop， ioc 提供了依赖注入的容器， aop解决了面向横切面的编程（比如日志、事务），然后在此两者的基础上实现了其他延伸产品的高级功能。

Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用来开发 web 应用。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这就是 SpringBoot，

**所以简练的说，spring是一个引擎，springMVC是基于Spring的一个MVC框架，springboot是一套快速开发整合包，Spring Cloud事实上是一整套基于Spring Boot的微服务解决方案。它为开发者提供了很多工具，用于快速构建分布式系统的一些通用模式，例如：注册中心、服务发现、限流、网关、等**

spring是一个生态体系，springframework是一个一站式的轻量级的java开发框架，核心是控制反转（IoC）和面向切面（AOP），针对于开发的WEB层(springMVC)、业务层(IoC)、持久层(jdbcTemplate)等都提供了多种配置解决方案。

### 4.9：SpringBoot和SpringCloud的区别/关系？

**关系:** SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系 （cloud依赖于boot）

区别: SpringBoot专注于快速、方便的**开发单个微服务**，SpringCloud关注**全局的服务治理**框架

### 4.10：feign 和 openfeign 有什么区别？

相同点：二都都有服务远程调用的功能

不同点1、Feign 本身不支持 Spring MVC 的注解，它有一套自己的注解。openfeign 支持springMVC注解，我们springcloud中用的是openfeign

### 4.11：feign的底层原理？

- 首先通过@EnableFeignCleints注解开启FeignCleint
- 根据Feign的规则实现接口，并加@FeignCleint注解
- 程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。
- 当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate
- RequesTemplate再生成Request
- Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp
- 最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。

## 五：redis & mongodb & mysql

### 5.1：redis的数据类型，以及每种数据类型的使用场景？



**String：最基本的数据类型，一个key对应一个value**

**应用场景：缓存，计数，共享session，限速**

**Hash：hash是一个键值对集合**

**应用场景：id作为key，用户属性最为值**

**List：list列表是简单的字符串序列，按照插入顺序排序，可以添加一个元素到头部或尾部**

**Set：是一种无序集合，集合中元素没有先后排序，不重复，有重复的可以自动去重**

**应用场景：新闻按照用户投票和时间排序**

**Zset：Redis zset和set一样也是string类型元素的集合，且不允许重复的成员**

**应用场景：存储全班同学的成绩，做排名**

1.String

这个没啥好说的，最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。我们项目用户登录获取短信验证码、还有首页广告位及banner图这些热点数据都是放的String类型

2.Hash

这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。

我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。

3.List

使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。

4.Set

因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？

因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。

另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

5.Sorted Set

Sorted Set多了一个权重参数 Score，集合中的元素能够按Score 进行排列。可以做排行榜应用，取TOP N 操作。

### 5.2:Redis持久化机制?

RDB 和AOF两种方式  

RDB持久化机制

对Redis中的数据执行周期性的持久化

AOF机制

将每条写命令作为日志，以append-only模式写入一个日志文件，在Redis重启时，通过回放日志中的写入指令来重构整个数据，

我们项目用的是使用RDB的方式

### 5.3： 缓存穿透、缓存击穿、缓存雪崩、缓存预热、缓存同步？

穿透：缓存和数据库中都没有数据

跟新：数据库中的数据发生变化，缓存中没有，给缓存加个定时跟新，以免数据库和缓存数据不一致

预热：系统上线后，提前将数据库中的数据加载到缓存中

雪崩：指缓存中数据大量过期，而查询量巨大，引起数据库压力大而down机

- 缓存穿透：

缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空，这就相当于进行了两次无用的查询。像这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题

解决办法

最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空，不管是数据不存在，还是系统故障，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

- 缓存击穿：

是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个key不停进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞.

解决办法

1：设置热点key永不过期，2：设置redis分布式锁

- 缓存雪崩

是指在某一个时间段，缓存集中过期失效，比方说：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

解决办法：

一个简单方案就是缓存失效时间分散开，不设置固定的实效时间，采用随机失效的策略来解决。

最多的解决方案就是锁，或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上

- 缓存预热：

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

操作方式：

1、直接写个缓存刷新页面，上线时手工操作下；

2、数据量不大，可以在项目启动的时候自动进行加载；

- 缓存更新：

1、定时去清理过期的缓存；

2.、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存



### 5.4： redis集群？

Redis本身就支持集群操作redis_cluster，集群至少需要3主3从，且每个实例使用不同的配置文件，主从不用配置，集群会自己选举主数据库和从数据库，为了保证选举过程最后能选出leader，就一定不能出现两台机器得票相同的僵局，所以一般的，要求集群的server数量一定要是奇数，也就是2n+1台，并且，如果集群出现问题，其中存活的机器必须大于n+1台，否则leader无法获得多数server的支持，系统就自动挂掉。所以一般是3个或者3个以上的奇数节点。

Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。哨兵的作用就是监控redis主、从数据库是否正常运行，主数据库出现故障自动将从数据库转换为主数据库

我们公司搭建的redis集群是用的ruby脚本配合搭建的，我们一共搭建了6台服务器，3主3备，他们之间通信的原理是有一个乒乓协议进行通信的，我再给你说下一他们往里存储数据的机制吧，其实这个redis搭建好集群以后每个节点都存放着一个hash槽，每次往里存储数据的时候，redis都会根据存储进来的key值算出一个hash值，通过这个hash值可以判断到底应该存储到哪一个哈希槽中，取的时候也是这么取的，这就是我了解的redis集群

### 5.5： redis分布式锁？

这个分布式锁这里，我们原来传统的项目都在单台服务器上部署用java里的锁synchronized这个同步锁就行，但是他这个是针对对象的锁，但是我们分布式的项目需要把项目部署到多台服务器上，每台服务器的对象都不同，所以就得考虑用分布式锁，这块实现起来也比较简单，其实这个锁就是redis中的一个key-value的一对值，在使用的时候吧，首先使用setnx方法进行尝试加锁，并可以设置过期时间，如果返回1则代表加锁成功，然后立即对这个锁设置一个实效时间，防止服务宕机，锁一致存在，在处理完业务逻辑之后，删除锁就行了，其他线程就可以获取锁进行业务了

### 5.6：MongoDB和redis 有什么区别？

1、内存管理机制：Redis数据全部存在内存，定期写入磁盘，MongoDB数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘

2：支持的数据结构：Redis 支持的数据结构丰富，包括hash、set、list等。MongoDB数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。

3：性能：mongodb依赖内存，TPS较高；Redis依赖内存，TPS非常高。性能上Redis优于MongoDB。

4：事务支持情况：Redis事务支持比较弱，只能保证事务中的每个操作连续执行；mongodb不支持事务。

### 5.7 : mysql索引都有哪些？如何创建索引？

MySQL的索引有两种分类方式：逻辑分类和物理分类。

按照逻辑分类，索引可分为：

主键索引：一张表只能有一个主键索引，不允许重复，不允许为null；

唯一索引：数据列不允许重复，允许为NULL值，一张表可有多个唯一索引，但是一个唯一索引只能包含

一列，比如身份证号码，卡号都可以作为唯一索引；

普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许NULL值插入；

全文索引：让搜索关键词更高效的一种索引；

按照物理分类，索引可分为：

聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，

如果还是没有的画，就采用Innodb存储引擎为每行数据内置的6字节rowid作为聚集索引。每张表只有一个聚集索引，

因为聚集索引的兼职的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表

现（相对于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重（一般不会让没有语义的自增

id充当聚集索引）；

非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集

索引；

创建主键索引

alter table t add primary key add(`id`)

创建唯一索引

alter table t add unique(`username`)

创建普通索引

alter table t add indexindex_name(`username`)

创建全文索引

alter table t add fulltext (`username`)

### 5.8 : mysql搜索引擎知道哪些？有什么区别？默认搜索引擎是什么？

**InnoDB ****存储引擎****:******

优点：InnoDB的优势在于支持外键, 支持行级锁，提供了良好的事务处理、崩溃修复能力和并发控制。索引使用的是B+Tree

缺点:   读写效率较差，占用的数据空间相对较大。

**MyISAM ****存储引擎****:******

不支持事务、支持表级锁、支持全文搜索。

MyISAM 存储引擎表由数据文件和索引文件组成,我们项目中常用到的是innoDB。



我了解到的数据库搜索引擎有MyISAM、InnoDB、BDB、MEMORY等，对于 MySQL 5.5 及更高版本，默认的存储引擎是 InnoDB。在 5.5 版本之前，MySQL 的默认存储引擎是 MyISAM，

**mysql中事务隔离级别 读未提交，读已提交，可重复读，串行化四个！默认是可重复读，**我们在项目中一般用**读已提交(Read Commited)**这个隔离级别

•      InnoDB 存储引擎：

o      支持自增长列（auto_increment），自增长列的值不能为空，如果在使用的时候为空的话就会从现有的最大值自动+1，如果有但是比现在的还大，则就保存这个值。

o      支持外键（foreignkey），外键所在的表称为子表而所依赖的表称为父表。

o      支持事务，回滚以及系统崩溃的修复能力，并且支持多版本并发控制的事务安全。

o      支持mvcc（多版本并发控制）的行级锁，就是通过多版本控制来实现的乐观锁

o      索引使用的是B+Tree

优缺点：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

•      MyISAM 存储引擎 

不支持事务、支持表级锁

支持全文搜索

缓冲池只缓存索引文件，

不缓存数据文件 MyISAM 存储引擎表由数据文件（MYD）和索引文件（ MYI）组成

我们项目中常用到的是innoDB，InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全，但是对比Myisam的存储引擎InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

### 5.9: mysql如何查看索引是否生效？

使用 explain 执行计划查看在sql前面加入关键字explain 查询出的结果查看type类型检查是否有执行索引

举例：EXPLAIN select * from table where id=2;我们一般优化sql语句的话，type级别都要至少达到ref级别，就是每次查询必须要使用索引

explain之后返回的列 type字段描述

type类型字段

All：最坏的情况,全表扫描

Index：和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。

主要优点就是避免了排序, 但是开销仍然非常大。

Range：范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。

当使用=、 <>、>、>=、<、<=、IS NULL、<=>、BETWEEN 或者 IN 操作符,

用常量比较关键字列时,可以使用 range

Ref：一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。

### 5.10: mysql查询语句优化？

对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建索引。

•	应尽量避免在 where 子句中对字段进行 null 值判断，使用 or 来连接条件，in 和 not in 也要慎用 

•	应尽量避免以%开头的模糊查询。

•	应尽量避免在 where 子句中对字段进行表达式操作、函数操作、!=或<>操作符，这将导致放弃使用索引而进行全表扫描。





对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

•      应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行 全表扫描。

•      应尽量避免在 where 子句中对字段进行 null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询:selectid from t where num=0 

•      应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引 而进行全表扫描，如：select id from t where num=10 or num=20 ，可以使用可以这样查询： selectid from t where num=10 union all select id from t where num=20

•      以%开头的模糊查询也会导致全表扫描： select id from t where name like '%abc%'，如果要提高效率的话，可以考虑全文检索来解决。 

•      in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select idfrom t where num between 1 and 3

•      应尽量避免在 where 子句中对字段进行表达式操作，这将导致放弃;l使用索引 而进行全表扫描。如：selectid from t where num/2=100应改为: select id from t where num=100*2

•      应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而 进行全表扫描。

### 5.11： mysql存储过程和视图？

存储过程：存储程序是被存储在服务器中的组合SQL语句，经编译创建并保存在数据库中，用户可通过存储过程的名字调用执行。存储过程核心思想就是数据库SQL语言层面的封装与重用性。使用存储过程可以较少应用系统的业务复杂性，但是会增加数据库服务器系统的负荷，所以在使用时需要综合业务考虑。

视图：视图本身是一张虚拟表，不存放任何数据。在使用SQL语句访问视图的时候，获取的数据是MySQL从其它表中生成的，视图和表在同一个命名空间（因为表和视图共享数据库中相同的名称空间，因此，数据库不能包含具有相同名称的表和视图）。视图查询数据相对安全，视图可以隐藏一些数据和结构，只让用户看见权限内的数据，使复杂的查询易于理解和使用。

### 5.12： mysql行转列与列转行？

mysql中行转列我们用的是内部函数实现过，函数是cast  when then else end 这种

列转行使用 union 关键字  把多个select语句结果捏合到一个结果来实现

### 5.13： 分库分表中解释一下垂直和水平2种不同的拆分？

垂直拆分：是将单表，或者是有关联的表放在一个数据库，把原有的一个数据库拆分成若干个数据库。

水平拆分：是将一个很大的表，通过取模，按照日期范围等等拆分成若干个表.

### 5.14 : 分库分表中垂直分库方案会带来哪些问题？

垂直分库如果没有按照合理的业务逻辑去拆分，后期会带来跨库join，分布式事务等；

跨库join会导致查询性能低下，分布式事务下会导致因数据不一致造成很多脏数据的存在。

### 5.15： 搭建mycat的核心配置文件有哪些？

schema.xml，配置逻辑库表，分片和读写分离

rule.xml，具体的分片规则和分片算法

server.xml，配置默认的数据库和用户，表权限

### 5.16 :  什么叫垂直切分？什么叫混合切分？项目中有没有可能只用水平切分？

垂直拆分是将同样的系统按照应用场景(调用方)进行拆分。

比如一个交易系统的支付模块，上游有用户支付和商家支付两个调用流程。按照垂直拆分的规则就可以将支付模块拆分为用户支付和商家支付。

混合切分：项目组中如果有水平切分，那项目组里的开发方式就叫混合切分。或者项目组里就是单纯的垂直切分。

### 六：rabbitmq & kafka

### 6.1: rabbitmq的特性及为什么要使用？

  成功	

特性：

- 消息确认机制 (自动确认和手动确认) 默认使用自动确认
  - 自动确认: acknowledge='none'
  - 手动确认: acknowledge='manual'
- 持久化 
  - 交换器持久化、队列持久化和消息的持久化
- 过期时间（TTL）
  - 跟Redis的过期时间一样

为什么要使用：

- 异步处理  : 调用者无需等待

  将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间

- 应用程序**解耦合 ** : 解决了系统之间耦合调用的问题

  MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。

- 削峰 : 抵御洪峰流量，保护了主业务

  并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常.

  比如:

  在下单的时候就会往数据库写数据,但是在高峰期时候，并发量会突然激增,这时候直接访问数据库数据库会卡死. 这时候可以通过mq将消息保存起来,然后按照自己的消费能力来消费,这样慢慢写入数据库。

### 6.2：如何保证数据一定被发送？

使用本地消息表(mysql)和定时任务(quartz)和MQ的响应机制（ComfirmFallback，ReturnFallback）

在发送消息时,在本地的mysql数据库中进行记录一条待发送信息.一个定时任务不断检查，是否发送成功，如果发送成功，将记录状态修改.如果发送失败者再次发送

### 6.3： rabbitmq如何保证消息不丢失？保证数据一定会被消费，如何保证？(两者一个意思)

RabbitMQ中，消息丢失可以简单的分为三种：生产者丢失消息,消费者丢失消息和消息队列丢失消息

###### 生产者丢失消息

**解决方案:** 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息

###### 消息队列丢失消息

**解决方案:** 消息持久化。durable设置为true

###### 消费者丢失消息

**解决方案:** 

设置为手动ack确认机制，当消费者出现异常或者服务宕机时，MQ服务器不会删除该消息，而是会把消息重发给绑定该队列的消费者，

消息不重复消费

解决方案：使用本地消息去重表，每次消费先到表中查询是否消费的标识，如果消费过就直接ack回滚。

### 6.4： rabbitmq实现数据同步后,消费者挂掉这么办,回滚代码这么实现？

实现ReturnCallback接口重写returnedMessage方法，回滚发送方数据同步操作，具体回滚可以读取发送方记录表中业务ID然后进行回退操作。

### 6.5: 消息堆积是如何产生,如何解决消息堆积?

当消息生产的速度长时间，远远大于消费的速度时。就会造成消息堆积,比如''

- 生产者突然大量发布消息

- 消费者挂掉

  解决

  - 增加消费者的多线程处理
  - 增加多个消费者

### 6.6: rabbitmq常用的消息模式？

RabbitMQ工作模式：

**1、简单模式 HelloWorld**  

​	一个生产者、一个消费者

**2、工作队列模式 Work Queue**    

​	一个生产者、多个消费者（竞争关系）

**3、发布订阅模式 Publish/subscribe**    

​	需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列

**4、路由模式 Routing**    

​	需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列

**5、通配符模式 Topic**    

​	需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列

### 6.7: rabbitmq什么时候变成死信队列？

- 消息拒绝并且没有设置重新入队
- 消息过期
- 消息堆积，并且队列达到最大长度，先入队的消息会变成DLX   死信队列交换机 

### 6.8：kafka中的broker 是干什么的

broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站

### 6.9：kafka中的 zookeeper 起到什么作用，可以不用zookeeper么

zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖，

但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。

### 6.10：kafka 为什么那么快

顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。

Zero-copy 零拷技术减少拷贝次数

Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。

Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。

## 七：docker & linux

### 7.1：linux常用命令

除pwd、cd、ls、vim、tar -zxcf、unzip 等这些太low的入门级命令外

查看僵尸进程

ps -ef | grep java (先查java进程ID)

kill -9  PID(生产环境谨慎使用)

查看日志

ps    -ef | grep  '日志关键字'  --color      以红色字样筛选过滤打印日志中关键字

tail /cat   -n  10  test.log   查询日志尾部最后10行的日志;

tail -100f  test.log      实时监控100行日志；

tail -f grep test/log    打印实时日志

head -n 10  test.log   查询日志文件中的头10行日志;

head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;

### 7.2：docker中基本命令

docker search  xxx   在docker容器中搜索xxx镜像

docker pull  拉取镜像到docker容器

docker run -it    安装并运行拉取的容器

docker ps -a  查看docker中运行的容器

service stop  xxxx   停止docker容器中某个镜像

service start  xxxx   启动docker容器中某个镜像

docker exec -it   xxxx  /bin/bash   进入docker容器中某个镜像

###7.3：Dockerfile中最常见的指令是什么？

Dockerfile中包括FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME等10个指令。

1.FROM

格式为FROM image或FROM image:tag，并且Dockerfile中第一条指令必须是FROM指令，且在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令。

 

2.MAINTAINER

格式为MAINTAINER user_name user_email，指定维护者信息

3.RUN

格式为RUN command或 RUN["EXECUTABLE","PARAM1","PARAM2".....]，前者在shell终端中运行命令，/bin/sh-c command，例如：/bin/sh -c "echo hello"；后者使用exec执行，指定其他运行终端使用RUN["/bin/bash","-c","echohello"]

每条RUN指令将当前的镜像基础上执行指令，并提交为新的镜像，命令较长的时候可以使用\来换行。

4.CMD

支持三种格式：

CMD["executable","param1","param2"]，使用exec执行，这是推荐的方式。

CMD command param1 param2 在/bin/sh中执行。

CMD["param1","param2"] 

提供给

ENTERYPOINT

的默认参数。 



# 1.Spring

关于Spring的话，是一个按照设计模式精心打造的开源框架。

spring是一个大的工厂类，它的特点就是基于配置，在其配置文件中通过<bean>元素来创建实例对象。然后指定对应的全路径名称。spring通过配置文件用反射的方式，就可以直接帮我们获取到这个类的对象。

我们平时做项目一直都在用，不管是使用ssh还是使用ssm，都可以整合。Spring里面主要的就三点，就是IOC，DI,AOP。

Ioc是一种可以实现实现控制反转的编程思想，用于实现模块之间的解耦，

之所以可以实现控制翻转的原因就是IOC把对象的创建、初始化、销毁（生命周期）交给spring来控制，而不是由开发者控制。

DI就是把ioc容器的对象通过反射机制注入类中。功能

还有一核心AOP，就是一种面向切面编程的思想，AOP执行过程是一个纵向的过程，它是把每个方法当作一个点，基于这些点可以进行增强处理，形成了横向的切面,不改变原有代码结构,还添加了额外某种功能比如事务的控制和**日志打印**权限管理之类的。

# 2.springboot                

SpringBoot是我们最近的项目开始用的。我个人觉得SpringBoot比以前的    SpringMVC更好用，因为他的配置文件比起SpringMVC少太多了，springboot    只需要一个yml文件或properties几乎全部搞定,我们用SpringBoot时结合    MyBatis基本上配置下YML文件，就可以了，MyBatis全程用的注解方式开发。    SpringBoot和SpringMVC用法上大同小异，无非就是少了一些配置文件。启    动SpringBoot服务器的时候是他自带的Tomca和Jetty（粘忒）服务器，可以    通过main方法启动。启动的注解是@SpringBootApplication（啊泼类k什）,    我们也用过Spring的全家桶,SpringBoot+JPA+SpringCloud组件,然后把    springcloud里的每一个组件说一下,后面有答案

 

### 1.8.SpringBoot和SpringMVC与springCloud关系?1.springboot是springmvc的升级版,其实就把springmvc里的web.xml文件去掉了,改为全注解的开发2.SpringCloud通过Springboot把其他的通信组件等等进行了封装,你如果使用SpringCloud的,那就必须得使用SpringBoot,使用SpringBoot的话不一定非得使用SpringCloud.

### 2.1Mybatis框架简介

**Mybatis** **框架也是一个持久层框架，我们目前做的这个项目就是用的这个框架，我觉他相对于以前的hibernate（嗨卜内特）来说比较简单,把sql语句写在配置文件里,解除了代码和sql语句的耦合度,写一些复杂的查询比较灵活.**

### 2.3.Mybatis 和 Hibernate 的区别

**Hibernate****一个是全封装，mybatis是半封装，使用hibernate做单表查询操作的时候比较简单(因为hibernate是针对对象进行操作的),但是多表查询起来就比较繁琐了,比如说5张表10张表做关联查询,就算是有SQLquery（昆儿蕊）那后续的维护工作也比较麻烦,还有就是Hibernate在Sql优化上执行效率上会远低于MyBatis(因为hibernate会把表中所有的字段查询出来,比较消耗性能)我们以前在做传统项目用过hibernate，但是现在基本上都在用mybatis.**

### 2.4.Mybatis缓存？

**mybatis****一级缓存是SqlSession级别的缓存，默认支持一级缓存，不需要在配置文件去配置。**

**mybaits****的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关<settingname='cacheEnabled'value='true'/>，还要在具体的mapper.xml中开启二级缓存：<mappernamespace='cn.hpu.mybatis.mapper.UserMapper'>**

## 2.JQuery中常用的选择器有哪些?

**常用的比较基础的  id  class 标签 这三个,其实开发的时候还有用到  attr这些属性选择器也常用,还有一些其他的,用的话,会去查API**

### .1.给我介绍一下redis

### 2.3.redis持久化方式有几种?

有RDB和AOF这两种，RDB是一种快照的方式来存储，每隔15s(默认是15S)对数据进行一次存储，,这种方式是redis的默认的持久化方式，这个间隔也可以通过配置文件里修改,这种存储方式性能比较高

还有一种是AOF是即时性的持久化方式，只要数据发生改变都会保存到硬盘一份,这种方式对数据的保存完整性比较高，但是性能比较差。而RDB存在的问题主要是服务器宕机或者断电，会造成数据丢失

### 2.4.使用redis有没有遇到过缓存穿透和缓存雪崩?

有遇到过,穿透就是,因为 redis都是按照key去缓存查询，如果不存在对应的value，就应该去数据库查找。如果key对应的value根本不存在，而且这个key并发请求量还特别大，那就会对后端系统造成很大的压力。这就叫做缓存穿透。

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力，这就叫“缓存雪崩”。解决办法是，对查询结果为空的情况也进行缓存，并且给缓存设置不同的有效期。当然redis容灾的最有效的方法还是搭建集群。在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

### 2.8.redis的数据类型?

我了解的有

字符串类型、

list，我们可以向list的两端添加数据

集合set，存放的数据是无序的，集合中的数据是不重复的，由于它是无序的，所以不能通过下标来获取制定元素、

order set有序集合、

hash

实际上我们常用的也就是string 和hash

redis是通过key-value存储的set key value  string

hset key value  hgetkey value

### 4.2.ElasticSearch和Solr的区别?

我知道他俩的底层都是基于lucene实现的,都是使用的lucene的[倒排索引](https://blog.csdn.net/u010558660/article/details/53407455)实现的,solr在实时建立索引的时候会产生IO阻塞查询性能会比ElasticSearch差一些,还有就是因为Solr自身不支持分布式,ElasticSearch是实时处理数据,而且默认的支持分布式的,可以组成一个网络,如果其中一台服务器宕机,会分配其他节点工作,可以扩展多台服务器,所以查询效率会更快,据说可以处理PB以上级别的数据.

### 5.1.ActiveMQ消息发送失败解决方案?在使用activeMQueue的时候有没有遇到过什么问题?

第一种用数据库配合着解决：

怎么配合呢咱们这边不是发送的商品的ID么，在发送之前把ID记录在数据库里面去，然后设置一个状态字段，0代表这个消息发送中,然后监听端进行消费,消费成功后把这个字段在改为1.然后就是几种突发情况,第一种情况比如说突然断电了然后我的消息首先是记录在数据库里面了，然后他的那个状态是不是为0啊，然后我们有一个用quartz写的定时器,每隔5分钟会去数据库跑个批然后把状态为0的数据,再重新发送一遍消息,直到消费成功为止.

第二种解决：  

​    在发送消息的时候设置提交的方式，改成手动提交的方式，在后台改成commit状态改成手动方式，如果发送成功的话，然后commit手动提交方式。

### 5.4.ActiveMQ使用场景

对于ActiveMQ在我们开发中,用它来降低过我们的项目耦合度,主要应用到这么几个场景，比如，我们的项目现在都是分布式的，咱们不可能在一个模块中实现所有的功能，就拿商品管理模块来说,当对商品做添加，修改，删除操作时，其他模块也有可能有相关连的变化，比如前台模块中的搜索，商品信息变了，索引库中内容也应该有相应的变化，这个时候呢，我们就需要用到一个通信机制，那ActiveMQ这种类型的框架我们就恰好需要的，可以在商品操作时，发送一个消息说我商品信息改变了，当然需要指明哪一个商品发生了变化，发送对应的商品id就行，在前台模块中，我们配置一个消息接收端，当接收到消息时，对索引库做下修改就行。

当然，除了商品添加同步更新索引库，像商品详情模块,在商品审核通过以后,想消息队列中发送了一个商品id到消息队列中,pageService工程中有一个监听类,可以生成相应的静态页面,,还有订单模块也有用到过，当执行生成订单，进行银行扣款，扣款成功，减库存啊，这种类型的操作，都可以通过ActiveMQ发生消息来实行同步操作。

### 5.7.说一下RabbitMQ？

RabbitMQ和ActiveMQueue不一样的地方是ActiveMQ发送消息是直接发送到队列中了，但是RabbitMQ发送消息的时候是先发送到交换器中如下图，而这个交换器在发送消息的方式我记得有三种,**直接模式**,**分裂模式**还有**主题模式**,直接模式发送消息的时候和ActiveMQ里的点对点差不多，没有走交换器直接发给了队列,分裂模式是需要在RabbitMQ里配置好多个消费者,发送方可以对每一个消费者都发送一条消息并且这个消息是唯一的,主题模式是发送完消息可以绑定到多个消息队列和多个消费者中,还可以配置模糊绑定,比如说,我们在配置的时候里面配置的后面以#.log  #号就是模糊的意思  以AA.log,bb.log这些都队列都能接收到消息  

### 6.1.介绍一下Nginx反向代理

他就是一个反向代理服务器,其实它的优点就是内存占用少,并发访问能力强,好些并发量高的大公司都会用到这个技术,像新浪,淘宝。它底是c语言实现的.要说这个反向代理,我就得先说一下正向代理,比如吧,我们平常开发时，要访问一台tomcat服务器,默认端口号是8080,那我们访问的时候可能就是localhost:8080,这样顺着来呢，我理解就是一个正向代理,这个时候，我们再来一台服务器端口号改成8081,通过不同端口号来访问俩台服务器, 但是当我们项目要上线的时候，如果需要把一个项目部署到俩台服务器上，比如淘宝，它的主界面不可能是在一台服务器上放着的，如果用户访问，就不能是访问8080或者8081这些端口了，这个时候，就需要有一个代理的服务器，能够给这两台服务器做一个代理，不需要访问对应端口，就可以访问到任意一台服务器。就是这个代理的服务器，所做的代理，我们可以理解成反向代理。反向代理严格的概念是通过代理服务器来接收网路上的请求，然后将请求转发给内部网路的服务器。而这个活nginx可以干，我们可以在nginx中配置端口，ip或者域名指向这些不同服务器的端口，甚至不同ip的服务器。这就是反向代理这个概念。

### 6.2.说下nginx负载均衡

Nginx还有一个重要的功能叫做负载均衡，我们做服务器的集群，怎样保证集群中服务器被均等的进行访问呢，不能说我们认为搭建好了服务器的集群它就会均衡的去访问，这个时候我们可以统一的去访问nginx这个服务器，在nginx的配置信息中，去配置好这些服务器，它配置文件是这样的，只要你配上，默认访问的比例就是一样的，这个就是负载均衡，当然nginx更厉害的是可以配置权重，比如说，我两台服务器，其中一台性能比另外一个性能好2倍，那我是不是应该访问性能好的服务器频率更高一些，咱们就可以在nginx的配置文件中配置一个weight属性，指定权重。当然还有其他一些配置的，比如有些服务器需要整修，那咱们就可以配置某台服务器暂时down掉，这样用户访问的时候，就不会访问到这台服务器，当修好之后，我们在把这个配置信息干掉就行了。

### 6.3.如何配置Nginx?

我们配置nginx是在nginx安装目录下的conf下有一个nginx.conf文件，主要是修改这个配置文件，比如咱们配置反向代理和负载均衡服务器，配置一个proxy_pass 指向代理服务器，配一下upstream server指向要访问的ip和端口，这个可以配置多个ip,可以设置weight权重什么的?

### 7.3.图片是怎么存储的?

​    我们用的是FastDFS文件服务器，FastDFS架构包括一个Tracker server  和一个 Storage server。

客户端请求Trackerserver  进行文件上传、下载，通过Tracker server 调用Storage server完成文件上传和下载。Tracker server可以完成负载均衡，它其实是这样的，这个Storageserver 会定时的向tracker server 发送自己的状态，tracker server就能知道那个storage server是空闲还是忙碌，当上传下载的时候，就会调用空闲的storage server ，当上传或下载的时候，这个storage server会生成filed id ，并将文件写到磁盘，返回一个路径信息和文件名，拿到路径信息我们就可以存到数据库或调用了。

## 13、第三方支付

我们常用的第三方支付有：支付宝、微信、聚合支付、付钱啦等。他们的原理都差不多。都是在点击支付时，直接调用第三方支付接口，传入appid、appsecret、订单编号、订单金额、回调url，直接跳转到第三方支付页面，接下来的支付过程，我们都不需要管，支付成功以后，第三方支付平台会直接回调我们的url。给我们返回：状态码、订单编号、支付流水号三个参数。我们首先根据订单编号，找到我们的订单，把支付流水号和状态码更新到我们的订单里边。回调url，一般有两种，一种用同步get方法回调，一种用异步的类似ajax方法回调，同步方法回调，一般是成功以后才会回调，并且只回调一次，回调成功以后我们可以直接跳转到我们的支付成功页面、异步方法回调，一般要求我们返回一个success字符串，第三方平台如果没有接受到success，就会认为没有调用成功，他会重复多次调用。比如支付宝会在25小时之内，调用8次；一般情况下第三方支付都采用第二种方式，因为比较安全，但支付宝是同时采用了两种。

我之前接触过一个B2B的电商，他们由于交易金额比较大，第三方支付无法实现，所以是直接和银行对接。大体上是，首先平台和银行签订合同，银行为平台开设一个总账号，当企业在平台注册以后，平台会为企业调用银行接口，创建一个子账号，这个子张号是挂在总账号下边的，也是一个在银行实际存在的账号，但是，只能通过外部银行卡给里边转账，而不能给外部银行卡转出。可以在子行号直接互相转账。

# 数据库方面

## 1.解释一下单列索引和联合索引?索引什么时候失效?，怎么添加索引？

​        单列索引是指在表的某一列上创建索引，联合索引是在多个列上联合创建索引。单列索引可以出现在where条件的任何位置，而联合索引需要按照一定的顺序来写。在多条件查询的时候，联合索引的效率更高，我们联合索引也最多创建两列

 

## 2.关系型数据库和非关系数据库的区别?

​        关系型数据库是表与表之间有关系比如一对多, 多对一,等值连接什么的,非关系型数据库就是里面没有多张表,没有什么关联

 

## 3.你有没有做过数据库建模,自己设计表和模块？

​        数据库建模就是使用PowerDsiger工具，先分析项目需求，前端先出相应的原型,根据原型,我开始做相应的表,设计初期的时候表会有些小浮动修改等,再根据需求设计详细字段。如果后期客户需求改变时，表结构后期跟着调整，就是这样使用工具不断完善过程就是建模。

 

## 4.说一下左连接和右连接的区别?

​        我给你举个例子吧,比如说有两张表,一张员工表,一张部门表,我们想通过两表等值连接的方式查询出员工信息和员工所在的部门,但是想把没有分配员工的部门也想展示出来,那就得用到外连接了,如果用左连接的话就把部门表放到左边就可以了.

 

## 6.where和having的区别?

​        他俩都是条件语句,where是在添加查询条件的使用的,having是在分组查询的时候添加分组条件用的.

 

## 7.数据库视图？

​        原来我们公司做过一个项目的时候，用的是5张表的联查，然后用sql语句来写的话，比较慢，比较麻烦，然后我们把这5张表的联查创建了了视图，然后就直接查找的是视图，查询速度快，这个视图就是只能做查询，而不能做增删改操作。

 

## 8.死锁？

​        打个比方，假设有P1和P2两个进程，都需要A和B两个资源，现在P1持有A等待B资源，而P2持有B等待A资源，两个都等待另一个资源而不肯释放资源，就这样无限等待中，这就形成死锁，这也是死锁的一种情况

## Springcloud五大组件

​         Eureka：注册中心，它是将各个微服务注册到注册中心，调用的时候无需自己找服务，而是注册中心会把符合要求的高诉你，还有提供端和注册中心之间通过心跳机制进行监视，如果有微服务出现了问题，他就会高诉你。

​         Fegin：远程调用，进行微服务之间的互相通信

​         Histrix：熔断器，比如a服务调用b服务，在调用端配置熔断器，设置失效时间，如果b服务出问题，然后他会切断调用，然后返回给你一个回调方法

​         Ribbon：负载均衡，比如一个调用端，两个b服务,但是有不知道调用那个，所以这时候就用到ribbon，他一共有三种方式，随机，轮询，自定义，默认是轮询，这样的话可以减轻服务器的压力，防止所有请求都在一台服务器上

​         Zuul：网关，我们在网关配置路由，给外部提供api，还配置一个统一的域名，外部可以通过域名来访问我们的项目。

**2.****解释ssm****？**

​                  Spring，springMVC，mybatis

​                  Spring就是一个里边装了很多bean的大容器，就不用在new对象了，还有spring的aop可以进行事务的管理

​                  springMVC处理前端对后台的请求

​                  mybatis就是管理数据库的

​         **8.** **mysql****的优化？**

​              **服务器优化方面可以优化服务器的硬件，可以使用高性能的硬件设备提高效率**

​              **可以修改mysql的参数，一般都在my.conf或者my.ini文件下面修改参数，具体怎么设置我也记得不太清了，需要用的时候直接去网上查就行**

​              **在使用mysql的时候使用索引，根据服务器配置索引的缓存**

​              **数据库结构优化可以将字段多的表分成多个表，还可以增加中间表，增加冗余的字段等等，如果存放数据上线，可以通过mycat配置读写分离**

​              **Sql****语句优化尽量少些\*号查询，少用like，in啊等等，尽量多起别名，尽量去掉<>，**

## mybatis执行流程

加载sqlMapConfig.xml文件

​         获取SqlSessionFactory

​         通过SqlSessionFactory创建SqlSession

​         SqlSession调用执行器(excutor)

​         传入参数

执行器通过mapStatement执行sql       

 输出结果

 

 

## ElasticSearch话术

#### 1、介绍一下ElasticSearch，以及在项目中的应用

 Java开发的基于lucene分布式全文搜索引擎。基于restful Web接口。在检索领域相当优秀，在我们项目中主要是负责检索商品信息。商品信息构成是比较复杂的，并且数据量巨大，至少会有几十万，如果使用mysql做检索，效率会非常低，并且对mysql造成很大的压力。

在使用过程中主要需要做几件事：

1、Es服务的安装，中文分词器使用IK分词器，这个主要是运维负责；

2、在项目中集成springDataElasticSearch框架，用来操作ES；

3、创建实体类，标注了一个Document注解，这个注解里声明了这个索引库的名称以及它的类型，还有他的分片儿信息，还有他的副本信息。在这个类中创建所有跟商品相关的字段。同样会有一些注解去标识他的数据类型，他的比如说id字段会有一个id注解，其他字段用@Field注解标注在es中存储的数据类型，是否进行分词等，有些字段也可以不加任何注解，es会根据存储的数据去判断字段在es中存储的类型。等其他的字段都建好之后，然后又新添加了一个统一的搜索字段，我们给它定义的名称叫all，我们会把经常搜索的数据全部定义到这个字段里。比方说商品标题、副标题、品牌等；

4、初始全量数据导入

使用springboot测试类实现导入，分批从mysql中取出，组装数据到，保存到es中

5、修改、新增、删除等增量数据导入

使用rabbitMQ实现，商品上下架的时候发送Mq消息，搜索微服务以及静态页面微服务实现ES数据的同步和静态页面的数据同步操作

6、使用es实现搜索

·        

使用all进行分词查询，搜索时，按照matchQuery做的，这个方法的做法是会把输入的关键词分词之后，然后去匹配，匹配的规则我们设置的是and的方式匹配，就是分词之后每个词条都匹配才算匹配，我们在项目里设置了个all字段，会把所有可能被分词的字段都会放到这个里边，只对这一个字段设置分词，关键字搜索的时候，都会去匹配这个字段，

·        

·        

使用规格参数聚合实现商品搜索规格参数的渲染

·        

·        

使用分类和品牌聚合实现商品分类和品牌查询的渲染

·        

·        

使用布尔查询实现规格参数、品牌、分类的过滤

·        

·        

实现分页、排序等需求

·        

#### 2、为什么使用Es？

 因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，es内部有个倒排索引的机制，普通的索引的原理是通过id寻找数据，而倒排索引是通过数据寻找id，它的大概原理是把需要分词的数据通过ik分词器分词之后，记录出每个词条对应的文档id，在进行搜索的时候，将搜索关键字分词之后，找到每个词条的文档id，然后在进行通过id搜索操作，大大提高了全文检索的效率，这也是在全文检索方面最常用的技术。

#### 3、 什么是桶（bucket）？什么是度量（metrics）？

 **桶**，是按照某种方式对数据进行分组，每一组数据在ES中称为一个`**桶**`，例如我们根据国籍对人划分，可以得到`**中国桶**`、`**英国桶**`，`**日本桶**`……或者我们按照年龄段对人进行划分：0~10,10~20,20~30,30~40等。分桶的方式有很多，比如按日期阶梯分组、按数值阶梯分组、按词条内容分组、按数值和日期范围分组等。

 **度量**，分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为`**度量**`。度量有求平均值、求最大最小值、求百分比、求和等。

 

#### 4、es内部存储的存储结构

es内部默认就是分布式的存储结构，每当创建一个索引库的时候，我们需要指定当前索引库的分片数和副本数，分片数就是把数据分布式的存放在分片上，所有分片的数据加起来就是整个索引库的数据量，分片数越多，数据存放的越分散，搜索的时候，es会检索每个分片的伤的数据一起返回。副本数是指在数据进入索引库的时候，同时需要备份的数量，如果副本数量越多，那么需要消耗的存储空间就会越多，过多的话会造成空间浪费，一般生产中使用的时候都用的默认的配置，就是5个分片，2个副本。

 

#### 1、解释一下单列索引和联合索引？

单列索引是指在表的某一列上创建索引；联合索引是在多个列上联合创建索引。

单列索引可以出现在where条件的任何位置，而联合索引需要按照一定的顺序来写。

在多条件查询的时候，联合索引的效率更高，我们联合索引也最多创建两列。